#include <HardwareSerial.h>
#include <stdio.h>

// DMX Configuration
#define DMX_CHANNELS 512
#define DMX_BREAK_THRESHOLD 100  // microseconds to detect break

// Fixture Configuration - MODIFY THESE VALUES
const int FIXTURE_START_CHANNEL = 1;    // Starting DMX channel (1-512)
const int FIXTURE_CHANNEL_COUNT = 4;    // Number of channels for your fixture

// DMX data storage
uint8_t dmxData[DMX_CHANNELS + 1];  // +1 for start code
bool dmxFrameComplete = false;
unsigned long lastByteTime = 0;
int dmxChannelCount = 0;
bool inFrame = false;

int min(int a, int b) {
  return (a < b) ? a : b;
}


void readDMX() {
  unsigned long currentTime = micros();
  
  // Check for break condition (gap in data)
  if (Serial1.available() == 0) {
    if (inFrame && (currentTime - lastByteTime) > DMX_BREAK_THRESHOLD) {
      // Break detected, prepare for new frame
      inFrame = false;
      dmxChannelCount = 0;
    }
    return;
  } else {
    printf(".");
  }
  // Process only a limited number of bytes per call to avoid blocking
  int bytesToProcess = min(Serial1.available(), 32); // Process max 32 bytes per loop
  
  for (int i = 0; i < bytesToProcess; i++) {
    printf("-");
    if (!Serial1.available()) break; // Safety check
    
    uint8_t incomingByte = Serial1.read();
    lastByteTime = micros();
    
    if (!inFrame) {
      // First byte after break should be start code (usually 0x00)
      if (dmxChannelCount == 0) {
        dmxData[0] = incomingByte;  // Store start code
        dmxChannelCount = 1;
        inFrame = true;
      }
    } else {
      // Store channel data
      if (dmxChannelCount <= DMX_CHANNELS) {
        dmxData[dmxChannelCount] = incomingByte;
        dmxChannelCount++;
        
        // Check if we have a complete frame
        if (dmxChannelCount > DMX_CHANNELS) {
          dmxFrameComplete = true;
          inFrame = false;
          dmxChannelCount = 0;
          break; // Exit early when frame is complete
        }
      }
    }
  }
}

uint8_t* readFixture(int startChannel, int channelCount) {
  // Static array to return fixture data
  static uint8_t fixtureData[32];  // Max 32 channels per fixture
  
  // Validate inputs
  if (startChannel < 1 || startChannel > DMX_CHANNELS || 
      channelCount < 1 || channelCount > 32 ||
      (startChannel + channelCount - 1) > DMX_CHANNELS) {
    // Return zeros if invalid
    memset(fixtureData, 0, channelCount);
    return fixtureData;
  }
  
  // Copy fixture channels from DMX data
  // DMX channels are 1-indexed, but our array is 0-indexed
  // dmxData[0] = start code, dmxData[1] = channel 1, etc.
  for (int i = 0; i < channelCount; i++) {
    fixtureData[i] = dmxData[startChannel + i];
  }
  
  return fixtureData;
}


void setup() {
  // Initialize Serial1 for DMX communication
  Serial1.begin(250000, SERIAL_8N2, 4, -1);
  
  printf("DMX Fixture Reader Starting...\n");
  printf("Reading fixture with %d channels starting at channel %d\n", 
         FIXTURE_CHANNEL_COUNT, FIXTURE_START_CHANNEL);
  
  // Initialize DMX data array
  memset(dmxData, 0, sizeof(dmxData));
}

void loop() {
  // Read DMX data
  readDMX();
  printf("loop");
  
  // If we have a complete frame, read the fixture data
  if (dmxFrameComplete) {
    uint8_t* fixtureData = readFixture(FIXTURE_START_CHANNEL, FIXTURE_CHANNEL_COUNT);
    
    // Print fixture data
    printf("Fixture data: [");
    for (int i = 0; i < FIXTURE_CHANNEL_COUNT; i++) {
      printf("%d", fixtureData[i]);
      if (i < FIXTURE_CHANNEL_COUNT - 1) {
        printf(", ");
      }
    }
    printf("]\n");
    
    dmxFrameComplete = false;  // Reset flag
    delay(50);  // Don't spam the output
  }
}