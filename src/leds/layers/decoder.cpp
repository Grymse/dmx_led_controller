#include "layer.h"
#include "debug.h"
#include "protocol.pb.h"
#include <pb_decode.h>
#include <vector>
#include "decoder.h"
#include "masks/masks.h"
#include "colors/colors.h"

/**
 * This function reads a stream of varint-encoded color values and decodes them into
 * CRGB objects, which are then stored in the provided vector. The decoding process
 * continues until there are no more bytes left in the stream.
 *
 * @param stream A pointer to the input stream from which color values are read.
 * @param field A pointer to the field iterator (not used in this function).
 * @param arg A pointer to a vector of CRGB objects where the decoded colors will be stored.
 * @return true if all color values are successfully decoded and stored; false if an error occurs during decoding.
 */
bool LayerDecoder::decode_colors(pb_istream_t* stream, const pb_field_iter_t* field, void** arg) {
  printf("YES");
  std::vector<CRGB>* colors = static_cast<std::vector<CRGB>*>(*arg);

  while (stream->bytes_left) {
    uint32_t value;
    if (!pb_decode_varint32(stream, &value)) {
      debug("\033[1;31mFailed to decode colors\033[0m\n", 0);
      return false;
    }
    colors->push_back(CRGB(value));
  }

  printf("INNER-colors size: %d\n", colors->size());
  return true;
}

/**
 * This function reads a stream of varint-encoded byte values and decodes them into
 * a vector of bytes. The decoding process continues until there are no more bytes
 * left in the stream.
 *
 * @param stream A pointer to the input stream from which byte values are read.
 * @param field A pointer to the field iterator (not used in this function).
 * @param arg A pointer to a vector of bytes where the decoded values will be stored.
 * @return true if all byte values are successfully decoded and stored; false if an error occurs during decoding.
 */
bool LayerDecoder::decode_bytes(pb_istream_t* stream, const pb_field_iter_t* field, void** arg) {
  printf("YES");
  std::vector<u8_t>* bytes = static_cast<std::vector<u8_t>*>(*arg);

  while (stream->bytes_left) {
    uint32_t value;
    if (!pb_decode_varint32(stream, &value)) {
      debug("\033[1;31mFailed to decode colors\033[0m\n", 0);
      return false;
    }
    bytes->push_back(value);
  }

  printf("INNER-bytes size: %d\n", bytes->size());
  return true;
}


bool decode_bytes2(pb_istream_t* stream, const pb_field_iter_t* field, void** arg) {
  printf("YES");
  std::vector<u8_t>* bytes = static_cast<std::vector<u8_t>*>(*arg);

  while (stream->bytes_left) {
    uint32_t value;
    if (!pb_decode_varint32(stream, &value)) {
      debug("\033[1;31mFailed to decode colors\033[0m\n", 0);
      return false;
    }
    bytes->push_back(value);
  }

  printf("INNER-bytes size: %d\n", bytes->size());
  return true;
}

/**
 * This function decodes a stream of varint-encoded layer data into a vector of ILayer objects.
 * The decoding process involves reading the stream, determining the type of layer being decoded,
 * and then decoding the appropriate data fields into the corresponding layer type.
 * Set args to a new std::vector<ILayer*>() to store the decoded layers.
 *
 * @param stream A pointer to the input stream from which layer data is read.
 * @param field A pointer to the field iterator (not used in this function).
 * @param arg A pointer to a vector of ILayer pointers where the decoded layers will be stored.
 * @return true if the layer is successfully decoded and stored; false if an error occurs during decoding.
 */
bool LayerDecoder::decode_layer(pb_istream_t* stream, const pb_field_iter_t* field, void** arg) {
  std::vector<ILayer*>* layers = static_cast<std::vector<ILayer*>*>(*arg);
  protocol_Layer incomingLayer = protocol_Layer_init_zero; // Empty layer to store incoming data in.
  ILayer* layer; // Empty pointer to store layer in.


  /**
   Here we declare both a colors and bytes array and assign all the necessary functions to decode them.
   This is necessary because the incomingLayer struct has a union for the payload, which can be any of the
   different layer types. We need to decode the colors and bytes arrays based on the type of layer that is
   being decoded. The decode function cannot tell us beforehand which type of layer it is decoding, so we
   need to decode the colors and bytes arrays for all possible layer types.

   NOTE: ANY REPEATED FIELDS NEED A VECTOR TO DECODE INTO.
    The incomingLayer struct is generated by nanopb and contains the necessary fields to decode the
    incoming data. The colors and bytes arrays are used to store the decoded values and are passed to the
    decode functions as arguments.
  */
  std::vector<CRGB> colors;
  std::vector<u8_t> bytes;
  /*
    pb_callback_t colors_callback = { LayerDecoder::decode_colors, &colors };
    pb_callback_t bytes_callback = { LayerDecoder::decode_bytes, &bytes };

    // For colors, we can use the colors array along with the decode_colors function
    incomingLayer.payload.fadeColor.colors = colors_callback;
    incomingLayer.payload.sectionsWaveColor.sections = colors_callback;
    incomingLayer.payload.sectionsColor.sections = colors_callback;
    incomingLayer.payload.switchColor.colors = colors_callback;

    // For bytes, we can use the bytes array along with the decode_bytes
    incomingLayer.payload.blinkMask.pattern = bytes_callback;
    incomingLayer.payload.sectionsWaveMask.sections = bytes_callback;
    incomingLayer.payload.sectionsMask.sections = bytes_callback; */


    // For colors, we can use the colors array along with the decode_colors function
  incomingLayer.payload.fadeColor.colors.arg = &colors;
  incomingLayer.payload.fadeColor.colors.funcs.decode = LayerDecoder::decode_colors;
  incomingLayer.payload.sectionsWaveColor.sections.arg = &colors;
  incomingLayer.payload.sectionsWaveColor.sections.funcs.decode = LayerDecoder::decode_colors;
  incomingLayer.payload.sectionsColor.sections.arg = &colors;
  incomingLayer.payload.sectionsColor.sections.funcs.decode = LayerDecoder::decode_colors;
  incomingLayer.payload.switchColor.colors.arg = &colors;
  incomingLayer.payload.switchColor.colors.funcs.decode = LayerDecoder::decode_colors;

  // For bytes, we can use the bytes array along with the decode_bytes
  incomingLayer.payload.blinkMask.pattern.arg = &bytes;
  incomingLayer.payload.blinkMask.pattern.funcs.decode = LayerDecoder::decode_bytes;
  incomingLayer.payload.sectionsWaveMask.sections.arg = &bytes;
  incomingLayer.payload.sectionsWaveMask.sections.funcs.decode = LayerDecoder::decode_bytes;
  incomingLayer.payload.sectionsMask.sections.arg = &bytes;
  incomingLayer.payload.sectionsMask.sections.funcs.decode = LayerDecoder::decode_bytes;

  // Perform the decoding of the incomingLayer
  if (!pb_decode(stream, protocol_Layer_fields, &incomingLayer)) {
    debug("\033[1;31mFailed to decode sequence\033[0m\n", 0);
    return false;  // Return empty sequence if decoding fails
  }

  // Large switch statement to determine which layer type is being decoded
  switch (incomingLayer.which_payload) {
    case protocol_Layer_fadeColor_tag:
      layer = new FadeColor(colors, incomingLayer.payload.fadeColor.duration);
      break;
    case protocol_Layer_rainbowColor_tag:
      layer = new RainbowColor(incomingLayer.payload.rainbowColor.duration, incomingLayer.payload.rainbowColor.length);
      break;
    case protocol_Layer_sectionsWaveColor_tag:
      layer = new SectionsWaveColor(colors, incomingLayer.payload.sectionsWaveColor.duration);
      break;
    case protocol_Layer_sectionsColor_tag:
      layer = new SectionsColor(colors, incomingLayer.payload.sectionsMask.duration);
      break;
    case protocol_Layer_singleColor_tag:
      layer = new SingleColor(CRGB(incomingLayer.payload.singleColor.color));
      break;
    case protocol_Layer_switchColor_tag:
      layer = new SwitchColor(colors, incomingLayer.payload.switchColor.duration);
      break;
    case protocol_Layer_blinkMask_tag:
      layer = new BlinkMask(bytes, incomingLayer.payload.blinkMask.duration);
      break;
    case protocol_Layer_invertMask_tag:
      layer = new InvertMask();
      break;
    case protocol_Layer_pulseSawtoothMask_tag:
      layer = new PulseSawtoothMask(incomingLayer.payload.pulseSawtoothMask.pulse_gap, incomingLayer.payload.pulseSawtoothMask.duration);
      break;
    case protocol_Layer_pulseMask_tag:
      layer = new PulseMask(incomingLayer.payload.pulseMask.pulse_gap, incomingLayer.payload.pulseMask.duration);
      break;
    case protocol_Layer_sawtoothMask_tag:
      layer = new SawtoothMask(incomingLayer.payload.sawtoothMask.wavelength, incomingLayer.payload.sawtoothMask.wavegap, incomingLayer.payload.sawtoothMask.duration);
      break;
    case protocol_Layer_sectionsWaveMask_tag:
      layer = new SectionsWaveMask(bytes, incomingLayer.payload.sectionsWaveMask.duration);
      break;
    case protocol_Layer_sectionsMask_tag:
      printf("SECTIONS dur+size %d %d\n", incomingLayer.payload.sectionsMask.duration, bytes.size());
      layer = new SectionsMask(bytes, incomingLayer.payload.sectionsMask.duration);
      break;
    case protocol_Layer_starsMask_tag:
      layer = new StarsMask(incomingLayer.payload.starsMask.frequency, incomingLayer.payload.starsMask.decaySpeed, incomingLayer.payload.starsMask.starLength);
      break;
    case protocol_Layer_waveMask_tag:
      layer = new WaveMask(incomingLayer.payload.waveMask.wavelength, incomingLayer.payload.waveMask.wavegap, incomingLayer.payload.waveMask.duration);
      break;
    default:
      debug("Missing layerId %d", incomingLayer.which_payload);
      return false;
  }

  // Push the decoded layer into the layers vector
  layers->push_back(layer);
  return true;
}